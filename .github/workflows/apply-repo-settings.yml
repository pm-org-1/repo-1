name: Apply Repo Settings
on:
    workflow_dispatch:
        inputs:
            repos:
                description: 'Comma-separated list of repo names (e.g. repo1, repo2)'
                required: true
        
            # Force recreation if the rule exists.
            force_recreate:
                description: 'Force apply the settings if the rule already exists'
                required: false
                type: boolean
                default: false

jobs:
    configure-repo:
        runs-on: ubuntu-latest #[self-hosted, bolt-ubuntu]
        steps:
        - name: Generate GitHub Access Token
          id: generate_token
          uses: actions/create-github-app-token@v2
          with:
            app-id: ${{ secrets.APP_ID }}
            private-key: ${{ secrets.APP_PEM }}
            owner: pm-org-1 #pfizer-analytics

        - name: Checkout full history
          uses: actions/checkout@v5
          with:
            fetch-depth: 0
            token: ${{ steps.generate_token.outputs.token }}

        - name: Configure Repository Settings
          uses: actions/github-script@v7
          with:
            github-token: ${{ steps.generate_token.outputs.token }}
            script: |
                const owner = context.repo.owner;
                console.log(`Owner: ${owner}`);

                const reposInput = `${{ github.event.inputs.repos }}` || '';
                console.log(`Repos Input: ${reposInput}`);
                
                if (!reposInput.trim()) {
                    console.log('No repository names provided. Exiting.');
                    return;
                }
                const repos = reposInput.split(',').map(r => r.trim()).filter(Boolean);

                // If the rule already exists and force_recreate is true, then delete and recreate.
                const forceRecreateInput = `${{ github.event.inputs.force_recreate }}`.toLowerCase();
                const forceRecreate = forceRecreateInput === 'true' || forceRecreateInput === '1'; 
                console.log(`Force recreate is set : ${forceRecreate}`);

                // Configurations section.                
                // Branches to apply protection rules
                const defaultBranches = ['main', 'dev'];
                console.log(`Default branches for protection: ${defaultBranches.join(', ')}`);
                
                // Define approving teams
                const teamSlugs = ["ias-team-admin"];
                console.log(`Approving teams slugs: ${teamSlugs.join(', ')}`);
                const approving_teams = [];

                // Replace with your GitHub App ID
                const githubAppId = 2271772; //1932357;

                // Atlassian team service account.
                const atlassianTeamServiceAccount = "atlassian-team-service-account";

                // Variable to hold API response
                let response;
                const fs = require('fs');

                // Get team ID by team slug from GitHub.
                async function getTeamId(teamSlug) {
                    try {
                        const response = await github.request('GET /orgs/{org}/teams/{team_slug}', {
                            org: owner,
                            team_slug: teamSlug
                        });
                        return response.data.id;
                    } catch (error) {
                        console.error(`Failed to get team ID for ${teamSlug}: ${error.message}`);
                        process.exit(1);
                    }
                }

                // Fetch team IDs and add to approving_teams array
                for (const teamSlug of teamSlugs) {
                    const id = await getTeamId(teamSlug);
                    if (id) {
                        approving_teams.push({"type": "Team", "id": id });
                    }
                }

                console.log(`Approving teams: ${JSON.stringify(approving_teams)}`);

                // Define environments and rules
                const environments = [
                    {
                        name: 'dev',
                        reviewers: [], 
                        allow_admin_bypass: true,
                        deployment_branch_policy: { protected_branches: false, custom_branch_policies: true },
                        deployment_branch_policies: [
                            {
                                type: 'branch',
                                name: 'dev'
                            }
                        ]
                    },
                    {
                        name: 'test',
                        reviewers: approving_teams,
                        allow_admin_bypass: true,
                        deployment_branch_policy: { protected_branches: false, custom_branch_policies: true },
                        deployment_branch_policies: [
                            {
                                type: 'branch',
                                name: 'main'
                            }
                        ]
                    },
                    {
                        name: 'prod',
                        reviewers: approving_teams,
                        allow_admin_bypass: true,
                        deployment_branch_policy: { protected_branches: false, custom_branch_policies: true },
                        deployment_branch_policies: [
                            {
                                type: 'tag',
                                name: '*RC*'
                            },
                            {
                                type: 'tag',
                                name: '*V*'
                            }
                        ]
                    }
                ];
                
                // Start processing each repo
                for (const repo of repos) {
                    console.log(`--------------------------------------------------------`);
                    console.log(`Applying settings to ${owner}/${repo}...`);
                    
                    // 1. Update repository settings
                    try {
                        response = await github.request('PATCH /repos/{owner}/{repo}', {
                            owner,
                            repo,
                            allow_squash_merge: true,
                            delete_branch_on_merge: true,
                            allow_auto_merge: false,
                            squash_merge_commit_title: 'PR_TITLE',
                            squash_merge_commit_message: 'PR_BODY'
                        });
                    } catch (error) {
                        if (error.status === 404) {
                            console.log(`üö´Skipping Repo ${owner}/${repo}, Response status: ${error.status}`);
                            continue;
                        }
                    }
                    if (response.status !== 200) {
                            console.error(`‚ùåFailed to update repository settings for ${owner}/${repo}, Response status: ${response.status}`);
                            continue;
                    } else {
                        console.log(`‚úÖUpdated repository settings for ${owner}/${repo}, Response status: ${response.status}`);
                    }

                    // 2. Enable merge queue
                    /*await github.request('PUT /repos/{owner}/{repo}/merge-queue', {
                        owner,
                        repo,
                        enabled: true
                    }); */

                    // 3. Ensure pr-title-check.yml exists and update with latest version
                    let prTitleCheckExists = false;
                    let sha = '';
                    try {
                        response = await github.request('GET /repos/{owner}/{repo}/contents/.github/workflows/pr-title-check.yml', {
                            owner,
                            repo
                        });
                        console.log(`Checking pr-title-check.yml existence Response status: ${response.status}`);
                        prTitleCheckExists = true;
                        sha = response.data.sha;
                    } catch (e) {
                        prTitleCheckExists = false;
                    }

                    // Read latest pr-title-check.yml from template
                    console.log(`Workspace path: ${process.env.GITHUB_WORKSPACE}`);
                    const prTitleCheckYml = fs.readFileSync(`${process.env.GITHUB_WORKSPACE}/.github/workflows/templates/pr-title-check.yml`, 'utf8');

                    // Create or update pr-title-check.yml in the repo
                    let putParams = {
                        owner,
                        repo,
                        path: '.github/workflows/pr-title-check.yml',
                        message: prTitleCheckExists ? 'Update pr-title-check workflow' : 'Add pr-title-check workflow',
                        content: Buffer.from(prTitleCheckYml).toString('base64'),
                        committer: {
                            name: 'github-actions[bot]',
                            email: 'praveena.m@pfizer.com'
                        },
                        author: {
                            name: 'github-actions[bot]',
                            email: 'praveena.m@pfizer.com'
                        },
                        signoff: true // -S
                    };
                    if (prTitleCheckExists && sha) {
                        putParams.sha = sha;
                    }

                    response = await github.request('PUT /repos/{owner}/{repo}/contents/.github/workflows/pr-title-check.yml', putParams);
                    console.log(`${prTitleCheckExists ? '‚úÖUpdated' : '‚úÖCreated'} pr-title-check.yml in ${owner}/${repo}, Response status: ${response.status}`);

                    // 4. Branch protection rules for protected branches
                    for (const branch of defaultBranches) {
                        // Check if branch exists
                        try {
                            response = await github.request('GET /repos/{owner}/{repo}/branches/{branch}', {
                                owner,
                                repo,
                                branch
                            });
                            console.log(`Branch ${branch} exists in ${owner}/${repo}, Response status: ${response.status}`);
                        } catch (error) {
                            console.log(`Branch ${branch} does not exist in ${owner}/${repo}, skipping branch protection.`);
                            
                            // create the branch from main branch if it does not exist.
                            if (branch !== 'main') {
                                try {
                                    // Get main branch reference
                                    const mainRefResponse = await github.request('GET /repos/{owner}/{repo}/git/ref/heads/main', {
                                        owner,
                                        repo
                                    });
                                    const mainSha = mainRefResponse.data.object.sha;

                                    // Create new branch from main
                                    response = await github.request('POST /repos/{owner}/{repo}/git/refs', {
                                        owner,
                                        repo,
                                        ref: `refs/heads/${branch}`,
                                        sha: mainSha
                                    });
                                    console.log(`‚úÖCreated branch ${branch} from main in ${owner}/${repo}, Response status: ${response.status}`);
                                } catch (createError) {
                                    console.error(`‚ùåFailed to create branch ${branch} in ${owner}/${repo}: ${createError.message}`);
                                    continue; // Skip to next branch
                                }
                            } else {
                                continue; // Skip to next branch
                            }
                            
                        }
                        response = await github.request('PUT /repos/{owner}/{repo}/branches/{branch}/protection', {
                            owner,
                            repo,
                            branch,
                            required_linear_history: true,
                            enforce_admins: false,
                            required_pull_request_reviews: {
                                require_code_owner_reviews: true,
                                require_last_push_approval: true
                            },
                            required_conversation_resolution: true,
                            required_status_checks: {
                                strict: true,
                                contexts: ['validate-pr-title']
                            },
                            restrictions: null,
                            allow_force_pushes: false,
                            required_signatures: true
                        });
                        console.log(`‚úÖBranch protection applied to ${owner}/${repo} on branch ${branch}, Response status: ${response.status}`);
                    }                   
                    

                    // 5. Tag protection rules for protected tags
                    async function createTagRuleset() {
                        try {
                            const response = await github.request('POST /repos/{owner}/{repo}/rulesets', {
                                owner,
                                repo,
                                name: 'Tag Protection',
                                target: 'tag',
                                enforcement: 'active',
                                "conditions": {
                                    "ref_name": {
                                        "exclude": [],
                                        "include": [
                                            "refs/tags/*RC*",
                                            "refs/tags/*V*"
                                        ]
                                    }
                                },
                                "rules": [
                                    {
                                        "type": "creation"
                                    },
                                    {
                                        "type": "update"
                                    },
                                    {
                                        "type": "deletion"
                                    }
                                ],
                               "bypass_actors": [
                                    {
                                        "actor_id": githubAppId, // For GitHub App
                                        "actor_type": "Integration",
                                        "bypass_mode": "exempt"
                                    }
                                ]
                            });

                            console.log(`‚úÖTag ruleset created, Response status: ${response.status}`);
                        } catch (error) {
                            console.error(`Failed to create tag ruleset: ${error.message}`);
                            process.exit(1);
                        }
                    }

                    async function deleteTagRuleset() {
                        try {
                            response = await github.request('GET /repos/{owner}/{repo}/rulesets', {
                                owner,
                                repo
                            });
                            const rulesets = response.data;
                            for (const ruleset of rulesets) {
                                if (ruleset.target === 'tag' && ruleset.name === 'Tag Protection') {
                                    await github.request('DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}', {
                                        owner,
                                        repo,
                                        ruleset_id: ruleset.id
                                    });
                                    console.log(`Deleted existing tag ruleset with ID: ${ruleset.id}`);
                                    break;
                                }
                            }
                        } catch (error) {
                            console.error(`Failed to delete existing tag ruleset: ${error.message}`);
                            process.exit(1);
                        }
                    }
                    
                    let tagRulesetExists = false;
                    try {
                        response = await github.request('GET /repos/{owner}/{repo}/rulesets', {
                            owner,
                            repo
                        });
                        const rulesets = response.data;
                        for (const ruleset of rulesets) {
                            if (ruleset.target === 'tag' && ruleset.name === 'Tag Protection') {
                                tagRulesetExists = true;
                                break;
                            }
                        }
                    } catch (error) {
                        console.error(`Failed to fetch rulesets: ${error.message}`);
                        process.exit(1);
                    }

                    // Apply rules for *RC* and *V* tags
                    if (!tagRulesetExists) {                        
                        await createTagRuleset();
                    }
                    else if (tagRulesetExists && forceRecreate) {
                        console.log(`Tag ruleset already exists in ${owner}/${repo}, deleting and recreating as per input.`);
                        await deleteTagRuleset();  
                        await createTagRuleset();
                    }
                    else {
                        console.log(`Tag ruleset already exists in ${owner}/${repo}, skipping creation as per input.`);
                    }                   

                    // 6. Create environments with protection rules
                    async function createEnvironment(env) {
                        await github.request('PUT /repos/{owner}/{repo}/environments/{environment_name}', {
                            owner,
                            repo,
                            environment_name: env.name,
                            reviewers: env.reviewers.map(r => (r)),
                            deployment_branch_policy: env.deployment_branch_policy,
                            wait_timer: 0,
                            can_admins_bypass: env.allow_admin_bypass
                        });
                        console.log(`‚úÖRecreated environment '${env.name}' with protection rules`);

                        // Create environment deployment branch policies if any
                        if (env.deployment_branch_policies) {
                            for (const policy of env.deployment_branch_policies) {
                                await github.request('POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies', {
                                    owner,
                                    repo,
                                    environment_name: env.name,
                                    type: policy.type,
                                    name: policy.name
                                });
                                console.log(`‚úÖAdded deployment branch policy '${policy.name}' to environment '${env.name}'`);
                            }
                        }
                    }

                    // Delete existing environment
                    async function deleteEnvironment(env) {
                        await github.request('DELETE /repos/{owner}/{repo}/environments/{environment_name}', {
                            owner,
                            repo,
                            environment_name: env.name
                        });
                        console.log(`‚úÖDeleted environment '${env.name}'`);
                    }

                    for (const env of environments) {
                        try {
                            // Check if environment exists
                            await github.request('GET /repos/{owner}/{repo}/environments/{environment_name}', {
                                owner,
                                repo,
                                environment_name: env.name
                            });
                            console.log(`Environment '${env.name}' already exists`);

                            if (forceRecreate) {
                                console.log(`Force recreate is enabled. Deleting and recreating environment '${env.name}'`);
                                await deleteEnvironment(env);
                                await createEnvironment(env);
                            }
                        } 
                        catch (error) {
                            if (error.status === 404) {
                                console.log(`Environment '${env.name}' does not exist. Creating...`);
                                await createEnvironment(env);
                            } else {
                                console.error(`‚ùåFailed to process environment '${env.name}': ${error.message}`);
                                process.exit(1);
                            }
                        }
                    }

                    // 7. Check and create SonarQube project properties file.
                    const sonarPropsPath = 'sonar-project.properties';
                    let sonarPropsExists = false;
                    let shaSonar = '';
                    try {
                        response = await github.request('GET /repos/{owner}/{repo}/contents/{path}', {
                            owner,
                            repo,
                            path: sonarPropsPath
                        });
                        shaSonar = response.data.sha;
                        sonarPropsExists = true;
                    } catch (error) {
                        if (error.status === 404) {
                            sonarPropsExists = false;
                            console.log(`SonarQube project properties file does not exist in ${owner}/${repo}`);
                        } else {
                            console.error(`‚ùåFailed to check SonarQube project properties file: ${error.message}`);
                            process.exit(1);
                        }
                    }
                    
                    // If exists, check if the sonar.projectKey matches expected format else recreate.
                    if (sonarPropsExists) {
                        const contentResponse = await github.request('GET /repos/{owner}/{repo}/contents/{path}', {
                            owner,
                            repo,
                            path:sonarPropsPath
                        });
                        const decodedContent = Buffer.from(contentResponse.data.content, 'base64').toString('utf-8');
                        const expectedProjectKey = `${owner}_${repo}`;
                        const projectKeyRegex = /^sonar\.projectKey=(.+)$/m;
                        const match = decodedContent.match(projectKeyRegex);
                        if (!match || match[1] !== expectedProjectKey) {
                            console.log(`SonarQube project key does not match expected format. Recreating file...`);

                            // Replace only the project key line.
                            const updatedContent = decodedContent.replace(projectKeyRegex, `sonar.projectKey=${expectedProjectKey}`);
                            const updatedContentBase64 = Buffer.from(updatedContent).toString('base64');
                            await github.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                                owner,
                                repo,
                                path: sonarPropsPath,
                                message: 'Update sonar-project.properties with correct project key',
                                content: updatedContentBase64,
                                sha: contentResponse.data.sha
                            });

                            console.log(`‚úÖUpdated SonarQube project properties file in ${owner}/${repo}`);
                        } else {
                            sonarPropsExists = false;
                        }
                    }

                    if (!sonarPropsExists) {
                        // Create sonar-project.properties file
                        const content = Buffer.from(`sonar.projectKey=${owner}_${repo}`).toString('base64');

                        response = await github.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                            owner,
                            repo,
                            path: sonarPropsPath,
                            message: 'Add sonar-project.properties',
                            content: content,
                            sha: shaSonar
                        });
                        console.log(`‚úÖCreated SonarQube project properties file in ${owner}/${repo}`);
                    } else {
                        console.log(`SonarQube project properties file already exists in ${owner}/${repo}`);
                    }

                    // 8. Add Atlassian team service account as a collaborator with write access
                    try {
                        response = await github.request('PUT /repos/{owner}/{repo}/collaborators/{username}', {
                            owner,
                            repo,
                            username: atlassianTeamServiceAccount,
                            permission: 'write'
                        });
                        console.log(`‚úÖAdded ${atlassianTeamServiceAccount} as collaborator with write access to ${owner}/${repo}, Response status: ${response.status}`);
                    } catch (error) {
                        console.error(`‚ùåFailed to add ${atlassianTeamServiceAccount} as collaborator to ${owner}/${repo}: ${error.message}`);
                    }

                    console.log(`‚úÖCompleted applying settings to ${owner}/${repo}`);
                    console.log(`--------------------------------------------------------`);
                }