name: Apply Repo Settings
on:
    workflow_dispatch:
        inputs:
            repos:
                description: 'Comma-separated list of repo names (e.g. repo1, repo2)'
                required: true
            # Skip the creations if already exists
            skip_if_exists:
                description: 'Skip creation if already exists (true/false)'
                required: false
                type: boolean
                default: true

jobs:
    configure-repo:
        runs-on: ubuntu-latest #[self-hosted, bolt-ubuntu]
        steps:
        - name: Generate GitHub Access Token
          id: generate_token
          uses: actions/create-github-app-token@v2
          with:
            app-id: ${{ secrets.APP_ID }}
            private-key: ${{ secrets.APP_PEM }}
            owner: pm-org-1 #pfizer-analytics

        - name: Checkout full history
          uses: actions/checkout@v5
          with:
            fetch-depth: 0
            token: ${{ steps.generate_token.outputs.token }}

        - name: Configure Repository Settings
          uses: actions/github-script@v7
          with:
            github-token: ${{ steps.generate_token.outputs.token }}
            script: |
                let response;
                const owner = context.repo.owner;
                console.log(`owner: ${owner}`);
                
                const reposInput = `${{ github.event.inputs.repos }}` || '';
                console.log(`repos Input: ${reposInput}`);
                if (!reposInput.trim()) {
                    console.log('No repository names provided. Exiting.');
                    return;
                }
                const repos = reposInput.split(',').map(r => r.trim()).filter(Boolean);
                console.log(`Input repos: ${repos.length === 1 ? repos[0] : repos.join(', ')}`);

                const fs = require('fs');
                for (const repo of repos) {
                    console.log(`Applying settings to ${owner}/${repo}...`);
                    // 1. Update repository settings
                    response = await github.request('PATCH /repos/{owner}/{repo}', {
                        owner,
                        repo,
                        allow_squash_merge: true,
                        delete_branch_on_merge: true,
                        allow_auto_merge: false,
                        squash_merge_commit_title: 'PR_TITLE',
                        squash_merge_commit_message: 'PR_BODY'
                    });
                    console.log(`Patch Repository settings Response status: ${response.status}`);

                    // 3. Ensure pr-title-check.yml exists and update with latest version
                    let prTitleCheckExists = false;
                    let sha = '';
                    try {
                        response = await github.request('GET /repos/{owner}/{repo}/contents/.github/workflows/pr-title-check.yml', {
                            owner,
                            repo
                        });
                        console.log(`Checking pr-title-check.yml existence Response status: ${response.status}`);
                        prTitleCheckExists = true;
                        sha = response.data.sha;
                    } catch (e) {
                        prTitleCheckExists = false;
                    }

                    // Read latest pr-title-check.yml from template
                    console.log(`Workspace path: ${process.env.GITHUB_WORKSPACE}`);
                    const prTitleCheckYml = fs.readFileSync(`${process.env.GITHUB_WORKSPACE}/.github/workflows/templates/pr-title-check.yml`, 'utf8');

                    // Create or update pr-title-check.yml in the repo
                    let putParams = {
                        owner,
                        repo,
                        path: '.github/workflows/pr-title-check.yml',
                        message: prTitleCheckExists ? 'Update pr-title-check workflow' : 'Add pr-title-check workflow',
                        content: Buffer.from(prTitleCheckYml).toString('base64'),
                        committer: {
                            name: 'github-actions[bot]',
                            email: 'praveena.m@pfizer.com'
                        },
                        author: {
                            name: 'github-actions[bot]',
                            email: 'praveena.m@pfizer.com'
                        },
                        signoff: true // -S
                    };
                    if (prTitleCheckExists && sha) {
                        putParams.sha = sha;
                    }

                    response = await github.request('PUT /repos/{owner}/{repo}/contents/.github/workflows/pr-title-check.yml', putParams);
                    console.log(`${prTitleCheckExists ? 'Updated' : 'Created'} pr-title-check.yml in ${owner}/${repo}, Response status: ${response.status}`);

                    // 4. Branch protection rules for main and dev branches
                    for (const branch of ['main', 'dev']) {
                        response = await github.request('PUT /repos/{owner}/{repo}/branches/{branch}/protection', {
                            owner,
                            repo,
                            branch,
                            required_linear_history: true,
                            enforce_admins: false,
                            required_pull_request_reviews: {
                                require_code_owner_reviews: true,
                                require_last_push_approval: true
                            },
                            required_conversation_resolution: true,
                            required_status_checks: {
                                strict: true,
                                contexts: ['validate-pr-title']
                            },
                            restrictions: null,
                            allow_force_pushes: false,
                            required_signatures: true
                        });
                        console.log(`Branch protection applied to ${owner}/${repo} on branch ${branch}, Response status: ${response.status}`);
                    }

                    
                    // Replace with your GitHub App ID
                    const githubAppId = 2271772; //1932357;

                    // Function to create tag protection rule
                    async function createTagRuleset() {
                        try {
                            const response = await github.request('POST /repos/{owner}/{repo}/rulesets', {
                                owner,
                                repo,
                                name: 'Tag Protection',
                                target: 'tag',
                                enforcement: 'active',
                                "conditions": {
                                    "ref_name": {
                                        "exclude": [],
                                        "include": [
                                            "refs/tags/*RC*",
                                            "refs/tags/*V*"
                                        ]
                                    }
                                },
                                "rules": [
                                    {
                                        "type": "creation"
                                    },
                                    {
                                        "type": "update"
                                    },
                                    {
                                        "type": "deletion"
                                    }
                                ],
                               "bypass_actors": [
                                    {
                                        "actor_id": githubAppId, // For GitHub App
                                        "actor_type": "Integration",
                                        "bypass_mode": "exempt"
                                    }
                                ]
                            });

                            console.log(`Tag ruleset created, Response status: ${response.status}`);
                        } catch (error) {
                            console.error(`Failed to create tag ruleset: ${error.message}`);
                            throw error;
                        }
                    }

                     async function deleteTagRuleset() {
                        try {
                            response = await github.request('GET /repos/{owner}/{repo}/rulesets', {
                                owner,
                                repo
                            });
                            const rulesets = response.data;
                            for (const ruleset of rulesets) {
                                if (ruleset.target === 'tag' && ruleset.name === 'Tag Protection') {
                                    await github.request('DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}', {
                                        owner,
                                        repo,
                                        ruleset_id: ruleset.id
                                    });
                                    console.log(`Deleted existing tag ruleset with ID: ${ruleset.id}`);
                                    break;
                                }
                            }
                        } catch (error) {
                            console.error(`Failed to delete existing tag ruleset: ${error.message}`);
                            throw error;
                        }
                    }

                    // Check and create tag rule set. If already exists and skip_if_exists is true, skip creation.
                    const skipIfExistsInput = `${{ github.event.inputs.skip_if_exists }}`.toLowerCase();
                    const skipIfExists = skipIfExistsInput === 'true' || skipIfExistsInput === '1'; 
                    let tagRulesetExists = false;
                    try {
                        response = await github.request('GET /repos/{owner}/{repo}/rulesets', {
                            owner,
                            repo
                        });
                        const rulesets = response.data;
                        for (const ruleset of rulesets) {
                            if (ruleset.target === 'tag' && ruleset.name === 'Tag Protection') {
                                tagRulesetExists = true;
                                break;
                            }
                        }
                    } catch (error) {
                        console.error(`Failed to fetch rulesets: ${error.message}`);
                        throw error;
                    }

                    // Apply rules for *RC* and *V*
                    if (!tagRulesetExists) {                        
                        await createTagRuleset();
                    }
                    else if (tagRulesetExists && !skipIfExists) {
                        console.log(`Tag ruleset already exists in ${owner}/${repo}, deleting and recreating as per input.`);
                        await deleteTagRuleset();  
                        await createTagRuleset();
                    }
                    else {
                        console.log(`Tag ruleset already exists in ${owner}/${repo}, skipping creation as per input.`);
                    }

                    // Define approving teams
                    const teamSlugs = ["ias-team-admin"];
                    const approving_teams = [];

                    // Get team ID for all the teams from GitHub.
                    async function getTeamId(teamSlug) {
                        try {
                            const response = await github.request('GET /orgs/{org}/teams/{team_slug}', {
                                org: owner,
                                team_slug: teamSlug
                            });
                            return response.data.id;
                        } catch (error) {
                            console.error(`Failed to get team ID for ${teamSlug}: ${error.message}`);
                            throw error;
                        }
                    }

                    // Fetch team IDs and update teams array
                    for (const teamSlug of teamSlugs) {
                        const id = await getTeamId(teamSlug);
                        if (id) {
                            approving_teams.push({"type": "Team", "id": id });
                        }
                    }

                    console.log(`Approving teams: ${JSON.stringify(approving_teams)}`);

                    // Define environments and rules
                    const environments = [
                        {
                            name: 'dev',
                            reviewers: [], 
                            allow_admin_bypass: true,
                            deployment_branch_policy: { protected_branches: true, custom_branch_policies: false }
                        },
                        {
                            name: 'test',
                            reviewers: approving_teams,
                            allow_admin_bypass: true,
                            deployment_branch_policy: { protected_branches: true, custom_branch_policies: false }
                        },
                        {
                            name: 'prod',
                            reviewers: approving_teams,
                            allow_admin_bypass: true,
                            deployment_branch_policy: { protected_branches: false, custom_branch_policies: true },
                            deployment_branch_policies: [
                                {
                                    type: 'tag',
                                    name: '*RC*'
                                },
                                {
                                    type: 'tag',
                                    name: '*V*'
                                }
                            ]
                        }
                    ];

                    
                    for (const env of environments) {
                        try {
                            // Check if environment exists
                            await github.request('GET /repos/{owner}/{repo}/environments/{environment_name}', {
                            owner,
                            repo,
                            environment_name: env.name
                            });
                            console.log(`Environment '${env.name}' already exists`);
                        } 
                        catch (error) {
                            if (error.status === 404) {
                                // Create environment
                                await github.request('PUT /repos/{owner}/{repo}/environments/{environment_name}', {
                                    owner,
                                    repo,
                                    environment_name: env.name,
                                    reviewers: env.reviewers.map(r => (r)),
                                    deployment_branch_policy: env.deployment_branch_policy,
                                    wait_timer: 0,
                                    can_admins_bypass: env.allow_admin_bypass
                                });
                                console.log(`Environment '${env.name}' created with protection rules`);

                                // Create environment deployment branch policies if any
                                if (env.deployment_branch_policies) {
                                    for (const policy of env.deployment_branch_policies) {
                                        await github.request('POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies', {
                                            owner,
                                            repo,
                                            environment_name: env.name,
                                            type: policy.type,
                                            name: policy.name
                                        });
                                        console.log(`Added deployment branch policy '${policy.name}' to environment '${env.name}'`);
                                    }
                                }
                            } else {
                                throw error;
                            }
                        }
                    }

                    console.log(`Settings applied to ${owner}/${repo}`);
                }