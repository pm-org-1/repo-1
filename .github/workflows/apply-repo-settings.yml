name: Apply Repo Settings
on:
    workflow_dispatch:
        inputs:
            repos:
                description: 'Comma-separated list of repo names (e.g. repo1, repo2)'
                required: true

jobs:
    configure-repo:
        runs-on: ubuntu-latest #[self-hosted, bolt-ubuntu]
        steps:
        - name: Generate GitHub Access Token
          id: generate_token
          uses: actions/create-github-app-token@v2
          with:
            app-id: ${{ secrets.APP_ID }}
            private-key: ${{ secrets.APP_PEM }}
            owner: pm-org-1 #pfizer-analytics

        - name: Checkout full history
          uses: actions/checkout@v5
          with:
            fetch-depth: 0
            token: ${{ steps.generate_token.outputs.token }}

        - name: Configure Repository Settings
          uses: actions/github-script@v7
          with:
            github-token: ${{ steps.generate_token.outputs.token }}
            script: |
                const owner = context.repo.owner;
                console.log(`owner: ${owner}`);
                
                const reposInput = `${{ github.event.inputs.repos }}` || '';
                console.log(`repos Input: ${reposInput}`);
                if (!reposInput.trim()) {
                    console.log('No repository names provided. Exiting.');
                    return;
                }
                const repos = reposInput.split(',').map(r => r.trim()).filter(Boolean);
                console.log(`Input repos: ${repos.length === 1 ? repos[0] : repos.join(', ')}`);

                const fs = require('fs');
                for (const repo of repos) {
                    console.log(`Applying settings to ${owner}/${repo}...`);
                    // 1. Update repository settings
                    let response = await github.request('PATCH /repos/{owner}/{repo}', {
                        owner,
                        repo,
                        allow_squash_merge: true,
                        delete_branch_on_merge: true,
                        allow_auto_merge: false,
                        squash_merge_commit_title: 'PR_TITLE',
                        squash_merge_commit_message: 'PR_BODY'
                    });
                    console.log(`Patch Repository settings Response status: ${response.status}`);



                    // 3. Ensure pr-title-check.yml exists and update with latest version
                    let prTitleCheckExists = false;
                    let sha = '';
                    try {
                        let response = await github.request('GET /repos/{owner}/{repo}/contents/.github/workflows/pr-title-check.yml', {
                            owner,
                            repo
                        });
                        console.log(`Checking pr-title-check.yml existence Response status: ${response.status}`);
                        prTitleCheckExists = true;
                        sha = response.data.sha;
                    } catch (e) {
                        prTitleCheckExists = false;
                    }

                    // Read latest pr-title-check.yml from template
                    console.log(`Workspace path: ${process.env.GITHUB_WORKSPACE}`);
                    const prTitleCheckYml = fs.readFileSync(`${process.env.GITHUB_WORKSPACE}/.github/workflows/templates/pr-title-check.yml`, 'utf8');

                    // Create or update pr-title-check.yml in the repo
                    let putParams = {
                        owner,
                        repo,
                        path: '.github/workflows/pr-title-check.yml',
                        message: prTitleCheckExists ? 'Update pr-title-check workflow' : 'Add pr-title-check workflow',
                        content: Buffer.from(prTitleCheckYml).toString('base64'),
                        committer: {
                            name: 'github-actions[bot]',
                            email: 'praveena.m@pfizer.com'
                        },
                        author: {
                            name: 'github-actions[bot]',
                            email: 'praveena.m@pfizer.com'
                        },
                        signoff: true // -S
                    };
                    if (prTitleCheckExists && sha) {
                        putParams.sha = sha;
                    }

                    let response = await github.request('PUT /repos/{owner}/{repo}/contents/.github/workflows/pr-title-check.yml', putParams);
                    console.log(`${prTitleCheckExists ? 'Updated' : 'Created'} pr-title-check.yml in ${owner}/${repo}, Response status: ${response.status}`);

                    // 4. Branch protection rules for main and dev branches
                    for (const branch of ['main', 'dev']) {
                        let response = await github.request('PUT /repos/{owner}/{repo}/branches/{branch}/protection', {
                            owner,
                            repo,
                            branch,
                            required_linear_history: true,
                            enforce_admins: false,
                            required_pull_request_reviews: {
                                require_code_owner_reviews: true,
                                require_last_push_approval: true
                            },
                            required_conversation_resolution: true,
                            required_status_checks: {
                                strict: true,
                                contexts: ['validate-pr-title']
                            },
                            restrictions: null,
                            allow_force_pushes: false,
                            required_signatures: true
                        });
                        console.log(`Branch protection applied to ${owner}/${repo} on branch ${branch}, Response status: ${response.status}`);
                    }

                    
                    // Replace with your GitHub App ID
                    const githubAppId = 2271772; //1932357;

                    // Function to create tag protection rule
                    async function createTagProtection(pattern) {
                        let response = await github.request('POST /repos/{owner}/{repo}/tag_protection', {
                            owner,
                            repo,
                            pattern: pattern,
                            allowed_actors: [
                            { type: 'App', id: githubAppId } // Allow GitHub App
                            ],
                            create: true,
                            update: true,
                            delete: true
                        });
                        console.log(`Tag protection rule for pattern: ${pattern}, Response status: ${response.status} `);
                    }

                    // Apply rules for *RC* and *V*
                    await createTagProtection('*RC*');
                    await createTagProtection('*V*');

                    // Define environments and rules
                    const environments = [
                        {
                            name: 'dev',
                            reviewers: [], 
                            allow_admin_bypass: true,
                            deployment_branch_policy: { protected_branches: true, custom_branch_policies: ['dev'] }
                        },
                        {
                            name: 'test',
                            reviewers: ['pm-org-1/ias-team-admin'],
                            allow_admin_bypass: true,
                            deployment_branch_policy: { protected_branches: true, custom_branch_policies: ['main'] }
                        },
                        {
                            name: 'prod',
                            reviewers: ['pm-org-1/ias-team-admin'],
                            allow_admin_bypass: true,
                            deployment_branch_policy: { protected_branches: true, custom_tag_policies: ['*RC*'] }
                        }
                    ];

                    
                    for (const env of environments) {
                        try {
                            // Check if environment exists
                            await github.request('GET /repos/{owner}/{repo}/environments/{environment_name}', {
                            owner,
                            repo,
                            environment_name: env.name
                            });
                            console.log(`Environment '${env.name}' already exists`);
                        } 
                        catch (error) {
                            if (error.status === 404) {
                                // Create environment
                                await github.request('PUT /repos/{owner}/{repo}/environments/{environment_name}', {
                                    owner,
                                    repo,
                                    environment_name: env.name,
                                    reviewers: env.reviewers.map(r => ({ type: 'User', id: r })),
                                    deployment_branch_policy: env.deployment_branch_policy,
                                    wait_timer: 0,
                                    can_admins_bypass: env.allow_admin_bypass
                                });
                                console.log(`Environment '${env.name}' created with protection rules`);
                            } else {
                                throw error;
                            }
                        }
                    }

                    console.log(`Settings applied to ${owner}/${repo}`);
                }